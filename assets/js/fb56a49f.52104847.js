"use strict";(globalThis.webpackChunkbook_frontend=globalThis.webpackChunkbook_frontend||[]).push([[408],{2940(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"ros2-module/ros2-architecture","title":"Chapter 1: ROS 2 Architecture","description":"This chapter provides an introduction to ROS 2 architecture, focusing on core concepts for humanoid robot control and AI integration.","source":"@site/docs/ros2-module/01-ros2-architecture.md","sourceDirName":"ros2-module","slug":"/ros2-module/ros2-architecture","permalink":"/first-phase-hackathon/docs/ros2-module/ros2-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/your-username/your-project-name/tree/main/packages/create-docusaurus/templates/shared/docs/ros2-module/01-ros2-architecture.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Physical AI & Humanoid Robotics \ud83e\udd16","permalink":"/first-phase-hackathon/docs/intro"},"next":{"title":"Chapter 2: Python Agents with rclpy","permalink":"/first-phase-hackathon/docs/ros2-module/python-agents-rclpy"}}');var r=s(4848),o=s(8453);const t={sidebar_position:1},a="Chapter 1: ROS 2 Architecture",c={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to ROS 2 as Robotic Middleware",id:"introduction-to-ros-2-as-robotic-middleware",level:2},{value:"Nodes",id:"nodes",level:2},{value:"Key Characteristics of Nodes:",id:"key-characteristics-of-nodes",level:3},{value:"Example Node Structure:",id:"example-node-structure",level:3},{value:"Topics and Message Passing",id:"topics-and-message-passing",level:2},{value:"Key Concepts:",id:"key-concepts",level:3},{value:"Publisher Example:",id:"publisher-example",level:3},{value:"Services",id:"services",level:2},{value:"Key Concepts:",id:"key-concepts-1",level:3},{value:"Communication Model",id:"communication-model",level:2},{value:"QoS Profiles:",id:"qos-profiles",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-1-ros-2-architecture",children:"Chapter 1: ROS 2 Architecture"})}),"\n",(0,r.jsx)(n.p,{children:"This chapter provides an introduction to ROS 2 architecture, focusing on core concepts for humanoid robot control and AI integration."}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Understand the purpose of ROS 2 as robotic middleware"}),"\n",(0,r.jsx)(n.li,{children:"Explain the concepts of nodes, topics, and services in ROS 2"}),"\n",(0,r.jsx)(n.li,{children:"Describe the communication model used in ROS 2"}),"\n",(0,r.jsx)(n.li,{children:"Understand how these components work together in a robotic system"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction-to-ros-2-as-robotic-middleware",children:"Introduction to ROS 2 as Robotic Middleware"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 (Robot Operating System 2) is not an operating system but rather a flexible framework for writing robot software. It is a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robot platforms."}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 serves as middleware that provides services designed for a heterogeneous computer cluster such as:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Hardware abstraction"}),"\n",(0,r.jsx)(n.li,{children:"Low-level device control"}),"\n",(0,r.jsx)(n.li,{children:"Implementation of commonly used functionality"}),"\n",(0,r.jsx)(n.li,{children:"Message-passing between processes"}),"\n",(0,r.jsx)(n.li,{children:"Package management"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"nodes",children:"Nodes"}),"\n",(0,r.jsx)(n.p,{children:"In ROS 2, a node is an executable that uses ROS 2 client libraries to communicate with other nodes. Nodes can publish or subscribe to messages, provide or use services, and manage parameters."}),"\n",(0,r.jsx)(n.h3,{id:"key-characteristics-of-nodes",children:"Key Characteristics of Nodes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each node is designed to perform a specific task"}),"\n",(0,r.jsx)(n.li,{children:"Nodes communicate with each other through messages"}),"\n",(0,r.jsx)(n.li,{children:"Multiple nodes can run simultaneously on the same machine or across multiple machines"}),"\n",(0,r.jsx)(n.li,{children:"Nodes are language-agnostic (can be written in different programming languages)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-node-structure",children:"Example Node Structure:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass MinimalNode(Node):\n    def __init__(self):\n        super().__init__('minimal_node')\n        self.get_logger().info('Hello from minimal node!')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MinimalNode()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"topics-and-message-passing",children:"Topics and Message Passing"}),"\n",(0,r.jsx)(n.p,{children:"Topics are named buses over which nodes exchange messages. Topic-based communication in ROS 2 follows a publish-subscribe pattern where publishers send messages to a topic and subscribers receive messages from a topic."}),"\n",(0,r.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Topics enable asynchronous communication"}),"\n",(0,r.jsx)(n.li,{children:"Multiple publishers can publish to the same topic"}),"\n",(0,r.jsx)(n.li,{children:"Multiple subscribers can subscribe to the same topic"}),"\n",(0,r.jsx)(n.li,{children:"Message types must be agreed upon beforehand"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"publisher-example",children:"Publisher Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalPublisher(Node):\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello World'\n        self.publisher.publish(msg)\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_publisher = MinimalPublisher()\n    rclpy.spin(minimal_publisher)\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"services",children:"Services"}),"\n",(0,r.jsx)(n.p,{children:"Services provide a request-response communication pattern in ROS 2. A service has a service server that processes the request and sends back a response, and a service client that makes the request and receives the response."}),"\n",(0,r.jsx)(n.h3,{id:"key-concepts-1",children:"Key Concepts:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Services enable synchronous communication"}),"\n",(0,r.jsx)(n.li,{children:"Each service has a specific request and response message type"}),"\n",(0,r.jsx)(n.li,{children:"Services are identified by name"}),"\n",(0,r.jsx)(n.li,{children:"Services can be called on demand"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"communication-model",children:"Communication Model"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 uses a distributed communication model based on the Data Distribution Service (DDS) standard. This provides:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Discovery"}),": Nodes automatically discover each other"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transport"}),": Multiple transport protocols (TCP, UDP, shared memory)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Quality of Service (QoS)"}),": Configurable policies for reliability, durability, etc."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Security"}),": Authentication, encryption, and access control"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"qos-profiles",children:"QoS Profiles:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reliability: Best effort or reliable delivery"}),"\n",(0,r.jsx)(n.li,{children:"Durability: Volatile or transient local"}),"\n",(0,r.jsx)(n.li,{children:"History: Keep last N samples or keep all samples"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 architecture provides a flexible framework for robot software development through its node-based design, topic-based message passing, and service-based request-response communication. The use of DDS as the underlying communication layer provides robust, scalable, and configurable communication between robot components."}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Identify three key differences between nodes and services in ROS 2."}),"\n",(0,r.jsx)(n.li,{children:"Explain why the publish-subscribe pattern is beneficial for robot communication."}),"\n",(0,r.jsx)(n.li,{children:"Describe a scenario where you would use a service instead of a topic."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>t,x:()=>a});var i=s(6540);const r={},o=i.createContext(r);function t(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);