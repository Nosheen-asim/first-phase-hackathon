"use strict";(globalThis.webpackChunkbook_frontend=globalThis.webpackChunkbook_frontend||[]).push([[728],{6494(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"isaac-ai-brain/nav2-humanoid-navigation","title":"Chapter 3: Nav2 for Humanoid Navigation","description":"This chapter covers NVIDIA Isaac Navigation and path planning fundamentals for humanoid robot navigation, including navigation pipelines for bipedal humanoids.","source":"@site/docs/isaac-ai-brain/03-nav2-humanoid-navigation.md","sourceDirName":"isaac-ai-brain","slug":"/isaac-ai-brain/nav2-humanoid-navigation","permalink":"/first-phase-hackathon/docs/isaac-ai-brain/nav2-humanoid-navigation","draft":false,"unlisted":false,"editUrl":"https://github.com/your-username/your-project-name/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-ai-brain/03-nav2-humanoid-navigation.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Isaac ROS & Visual SLAM","permalink":"/first-phase-hackathon/docs/isaac-ai-brain/isaac-ros-vslam"},"next":{"title":"Chapter 4: Perception-to-Navigation Flow","permalink":"/first-phase-hackathon/docs/isaac-ai-brain/perception-to-navigation"}}');var t=i(4848),s=i(8453);const o={sidebar_position:3},r="Chapter 3: Nav2 for Humanoid Navigation",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Isaac Navigation for Humanoid Robots",id:"introduction-to-isaac-navigation-for-humanoid-robots",level:2},{value:"Key Isaac Navigation Features:",id:"key-isaac-navigation-features",level:3},{value:"Humanoid Navigation Challenges:",id:"humanoid-navigation-challenges",level:3},{value:"Path Planning Fundamentals for Humanoid Robots",id:"path-planning-fundamentals-for-humanoid-robots",level:2},{value:"Humanoid-Specific Path Planning Considerations:",id:"humanoid-specific-path-planning-considerations",level:3},{value:"Path Planning Approaches:",id:"path-planning-approaches",level:3},{value:"Example: Humanoid Path Planning",id:"example-humanoid-path-planning",level:3},{value:"Navigation Pipelines for Bipedal Humanoids",id:"navigation-pipelines-for-bipedal-humanoids",level:2},{value:"Humanoid Navigation Pipeline Components:",id:"humanoid-navigation-pipeline-components",level:3},{value:"Perception for Humanoid Navigation:",id:"perception-for-humanoid-navigation",level:3},{value:"Example: Humanoid Navigation Pipeline",id:"example-humanoid-navigation-pipeline",level:3},{value:"Humanoid-Specific Navigation Challenges",id:"humanoid-specific-navigation-challenges",level:2},{value:"Balance and Stability Challenges:",id:"balance-and-stability-challenges",level:3},{value:"Terrain and Environment Challenges:",id:"terrain-and-environment-challenges",level:3},{value:"Computational Challenges:",id:"computational-challenges",level:3},{value:"Gait-Aware Navigation Planning Concepts",id:"gait-aware-navigation-planning-concepts",level:2},{value:"Gait Pattern Considerations:",id:"gait-pattern-considerations",level:3},{value:"Gait Types for Humanoid Navigation:",id:"gait-types-for-humanoid-navigation",level:3},{value:"Example: Gait-Aware Path Planning",id:"example-gait-aware-path-planning",level:3},{value:"Integration with Isaac Perception Systems",id:"integration-with-isaac-perception-systems",level:2},{value:"Perception-Planning Integration:",id:"perception-planning-integration",level:3},{value:"Safety Considerations:",id:"safety-considerations",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"chapter-3-nav2-for-humanoid-navigation",children:"Chapter 3: Nav2 for Humanoid Navigation"})}),"\n",(0,t.jsx)(e.p,{children:"This chapter covers NVIDIA Isaac Navigation and path planning fundamentals for humanoid robot navigation, including navigation pipelines for bipedal humanoids."}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(e.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understand Isaac Navigation for humanoid robots"}),"\n",(0,t.jsx)(e.li,{children:"Explain path planning fundamentals for humanoid robots"}),"\n",(0,t.jsx)(e.li,{children:"Describe navigation pipelines for bipedal humanoids"}),"\n",(0,t.jsx)(e.li,{children:"Understand humanoid-specific navigation challenges"}),"\n",(0,t.jsx)(e.li,{children:"Implement gait-aware navigation planning concepts"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-isaac-navigation-for-humanoid-robots",children:"Introduction to Isaac Navigation for Humanoid Robots"}),"\n",(0,t.jsx)(e.p,{children:"Isaac Navigation provides a comprehensive navigation system specifically designed to handle the unique challenges of humanoid robots. Unlike wheeled robots, humanoid robots must navigate with dynamic balance, limited step locations, and complex kinematic constraints."}),"\n",(0,t.jsx)(e.p,{children:"This navigation system integrates with the perception capabilities from Isaac ROS (covered in Chapter 2) and can utilize maps and localization data from the SLAM processes. The navigation system also builds on the digital twin concepts from Module 2, where we explored navigation simulation, but extends them specifically for humanoid locomotion patterns and balance constraints."}),"\n",(0,t.jsx)(e.h3,{id:"key-isaac-navigation-features",children:"Key Isaac Navigation Features:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gait-Aware Planning"}),": Path planning that considers the robot's walking pattern"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Balance"}),": Maintaining stability during navigation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Step Planning"}),": Selecting appropriate footstep locations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Terrain Adaptation"}),": Adapting to various ground types and obstacles"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Multi-Modal Navigation"}),": Combining walking with other locomotion modes"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"humanoid-navigation-challenges",children:"Humanoid Navigation Challenges:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Balance Maintenance"}),": Keeping the robot stable during movement"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Step Planning"}),": Determining where feet should go for stable locomotion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Kinematic Constraints"}),": Limited joint ranges and configurations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Stability"}),": Maintaining center of mass during walking"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Obstacle Avoidance"}),": Navigating around obstacles while maintaining balance"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"path-planning-fundamentals-for-humanoid-robots",children:"Path Planning Fundamentals for Humanoid Robots"}),"\n",(0,t.jsx)(e.p,{children:"Path planning for humanoid robots differs significantly from traditional mobile robot navigation due to the constraints of bipedal locomotion."}),"\n",(0,t.jsx)(e.h3,{id:"humanoid-specific-path-planning-considerations",children:"Humanoid-Specific Path Planning Considerations:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Kinematic Constraints"}),": Joint limits and workspace limitations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Balance"}),": Paths must maintain the robot's center of mass"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Step Sequence"}),": Planning must consider the sequence of foot placements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gait Patterns"}),": Different walking patterns for different speeds and conditions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Terrain Analysis"}),": Understanding surface properties for safe foot placement"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"path-planning-approaches",children:"Path Planning Approaches:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Footstep Planning"}),": Planning the sequence of foot placements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Center of Mass Trajectories"}),": Planning stable CoM paths"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Capture Point Planning"}),": Using capture point dynamics for stability"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Divergent Component of Motion (DCM)"}),": Advanced planning using DCM concepts"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"example-humanoid-path-planning",children:"Example: Humanoid Path Planning"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# Example of humanoid path planning with balance constraints\nimport numpy as np\nfrom geometry_msgs.msg import PoseStamped\nfrom nav_msgs.msg import Path\n\nclass HumanoidPathPlanner:\n    def __init__(self):\n        self.support_polygon = None  # Area where robot is stable\n        self.step_length = 0.3      # Maximum step length\n        self.step_width = 0.2       # Lateral step distance\n        self.com_height = 0.8       # Center of mass height\n\n    def plan_footsteps(self, start_pose, goal_pose, obstacles):\n        """\n        Plan a sequence of footsteps from start to goal\n        considering humanoid balance constraints\n        """\n        # Initialize support polygon around start position\n        self.support_polygon = self.calculate_support_polygon(start_pose)\n\n        # Plan footsteps using A* with humanoid constraints\n        footsteps = self.footstep_a_star(start_pose, goal_pose, obstacles)\n\n        return footsteps\n\n    def calculate_support_polygon(self, pose):\n        """\n        Calculate the support polygon based on current stance\n        """\n        # For a biped, support polygon is the area covered by feet\n        # This is a simplified example\n        polygon = []\n        # Add points around the current stance foot\n        for angle in np.linspace(0, 2*np.pi, 8):\n            x = pose.position.x + 0.1 * np.cos(angle)\n            y = pose.position.y + 0.1 * np.sin(angle)\n            polygon.append((x, y))\n        return polygon\n\n    def is_stable_support(self, left_foot, right_foot, com_position):\n        """\n        Check if the center of mass is within the support polygon\n        """\n        # Simplified stability check\n        support_polygon = [left_foot, right_foot]  # Simplified to line\n        # In reality, this would use more complex geometric calculations\n        return True  # Placeholder implementation\n\n    def generate_valid_steps(self, current_pose, obstacles):\n        """\n        Generate possible next steps that maintain stability\n        """\n        possible_steps = []\n\n        # Generate steps in different directions\n        for step_angle in np.linspace(0, 2*np.pi, 8):\n            step_x = current_pose.position.x + self.step_length * np.cos(step_angle)\n            step_y = current_pose.position.y + self.step_length * np.sin(step_angle)\n\n            # Check if step is valid (not in obstacle, maintains stability)\n            if self.is_valid_step(step_x, step_y, obstacles):\n                possible_steps.append((step_x, step_y))\n\n        return possible_steps\n\n    def is_valid_step(self, x, y, obstacles):\n        """\n        Check if a step is valid (no obstacles, maintains balance)\n        """\n        # Check for obstacles\n        for obs in obstacles:\n            if np.sqrt((x - obs.x)**2 + (y - obs.y)**2) < 0.1:  # 10cm clearance\n                return False\n        return True\n'})}),"\n",(0,t.jsx)(e.h2,{id:"navigation-pipelines-for-bipedal-humanoids",children:"Navigation Pipelines for Bipedal Humanoids"}),"\n",(0,t.jsx)(e.p,{children:"Navigation for bipedal humanoids requires specialized pipelines that account for the unique locomotion and stability requirements."}),"\n",(0,t.jsx)(e.h3,{id:"humanoid-navigation-pipeline-components",children:"Humanoid Navigation Pipeline Components:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Perception"}),": Understanding the environment and terrain"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Footstep Planning"}),": Determining where to place feet"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Trajectory Generation"}),": Creating CoM and joint trajectories"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Balance Control"}),": Maintaining stability during movement"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gait Adaptation"}),": Adjusting walking pattern based on terrain"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Reactive Control"}),": Handling unexpected obstacles or disturbances"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"perception-for-humanoid-navigation",children:"Perception for Humanoid Navigation:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Terrain Classification"}),": Identifying walkable surfaces"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Step Location Detection"}),": Finding suitable foot placement locations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Obstacle Detection"}),": Identifying obstacles to avoid"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Ground Plane Estimation"}),": Understanding surface orientation"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"example-humanoid-navigation-pipeline",children:"Example: Humanoid Navigation Pipeline"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# Example of humanoid navigation pipeline\nfrom nav2_core import Planner\nfrom geometry_msgs.msg import PoseStamped, Twist\nimport numpy as np\n\nclass HumanoidNavigator:\n    def __init__(self):\n        self.footstep_planner = FootstepPlanner()\n        self.balance_controller = BalanceController()\n        self.terrain_analyzer = TerrainAnalyzer()\n        self.gait_generator = GaitPatternGenerator()\n\n    def navigate_to_pose(self, goal_pose):\n        """\n        Navigate humanoid robot to goal pose\n        """\n        # 1. Analyze terrain between current and goal pose\n        terrain_map = self.terrain_analyzer.analyze_path(current_pose, goal_pose)\n\n        # 2. Plan footsteps considering terrain and balance\n        footsteps = self.footstep_planner.plan_path(\n            current_pose, goal_pose, terrain_map\n        )\n\n        # 3. Generate gait pattern for the planned footsteps\n        gait_pattern = self.gait_generator.generate_gait(footsteps)\n\n        # 4. Execute navigation with balance control\n        for step in footsteps:\n            self.execute_step(step)\n            self.balance_controller.update_balance()\n\n    def execute_step(self, step_pose):\n        """\n        Execute a single step while maintaining balance\n        """\n        # Move swing foot to target location\n        self.move_swing_foot(step_pose)\n\n        # Shift weight to new support foot\n        self.shift_weight()\n\n        # Update support polygon\n        self.update_support_polygon()\n\n    def move_swing_foot(self, target_pose):\n        """\n        Move the swing foot to target pose using inverse kinematics\n        """\n        # Calculate joint angles using humanoid kinematics\n        # Execute joint movements while maintaining balance\n        pass\n'})}),"\n",(0,t.jsx)(e.h2,{id:"humanoid-specific-navigation-challenges",children:"Humanoid-Specific Navigation Challenges"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots face unique challenges that wheeled or tracked robots do not encounter."}),"\n",(0,t.jsx)(e.h3,{id:"balance-and-stability-challenges",children:"Balance and Stability Challenges:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Center of Mass Management"}),": Keeping CoM within support polygon"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Walking"}),": Maintaining balance during motion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Recovery from Disturbances"}),": Handling pushes or uneven terrain"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Turning and Lateral Movement"}),": Challenging for bipedal robots"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"terrain-and-environment-challenges",children:"Terrain and Environment Challenges:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Step Height Limitations"}),": Cannot step over high obstacles"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Surface Variability"}),": Different friction and stability properties"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Narrow Passages"}),": Limited clearance for wide stance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Inclined Surfaces"}),": Challenging for bipedal locomotion"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"computational-challenges",children:"Computational Challenges:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Real-time Requirements"}),": Balance control requires high frequency"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Complex Kinematics"}),": 30+ degree of freedom systems"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Planning"}),": Adjusting plans based on balance state"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Multi-objective Optimization"}),": Balancing speed, stability, and energy"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"gait-aware-navigation-planning-concepts",children:"Gait-Aware Navigation Planning Concepts"}),"\n",(0,t.jsx)(e.p,{children:"Gait-aware navigation planning considers the robot's walking pattern when planning paths and trajectories."}),"\n",(0,t.jsx)(e.h3,{id:"gait-pattern-considerations",children:"Gait Pattern Considerations:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Double Support Phase"}),": When both feet are on ground"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Single Support Phase"}),": When one foot is swinging"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Step Timing"}),": Proper coordination of steps"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Foot Clearance"}),": Ensuring feet clear ground during swing"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"gait-types-for-humanoid-navigation",children:"Gait Types for Humanoid Navigation:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Static Walk"}),": CoM always within support polygon"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Walk"}),": CoM may extend beyond support polygon"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Trot"}),": Both feet move simultaneously (for stability)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Pacing"}),": Lateral sequence for specific terrain"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"example-gait-aware-path-planning",children:"Example: Gait-Aware Path Planning"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# Example of gait-aware path planning\nclass GaitAwarePlanner:\n    def __init__(self):\n        self.gait_patterns = {\n            'walk': {'step_length': 0.3, 'step_height': 0.05, 'period': 0.8},\n            'trot': {'step_length': 0.2, 'step_height': 0.03, 'period': 0.6},\n            'careful': {'step_length': 0.1, 'step_height': 0.08, 'period': 1.2}\n        }\n        self.current_gait = 'walk'\n\n    def select_gait_for_terrain(self, terrain_type):\n        \"\"\"\n        Select appropriate gait based on terrain characteristics\n        \"\"\"\n        if terrain_type == 'rough':\n            return 'careful'\n        elif terrain_type == 'slippery':\n            return 'trot'\n        else:\n            return 'walk'\n\n    def plan_with_gait_constraints(self, path, terrain_map):\n        \"\"\"\n        Plan path considering gait-specific constraints\n        \"\"\"\n        gait_aware_path = []\n\n        for segment in path:\n            # Determine appropriate gait for this terrain segment\n            gait = self.select_gait_for_terrain(\n                terrain_map.get_terrain_type(segment)\n            )\n\n            # Generate footsteps with gait-specific parameters\n            footsteps = self.generate_footsteps_for_gait(\n                segment, self.gait_patterns[gait]\n            )\n\n            gait_aware_path.extend(footsteps)\n\n        return gait_aware_path\n\n    def generate_footsteps_for_gait(self, path_segment, gait_params):\n        \"\"\"\n        Generate footsteps specific to the gait pattern\n        \"\"\"\n        footsteps = []\n        step_length = gait_params['step_length']\n\n        # Calculate footsteps along the path segment\n        # considering the gait-specific constraints\n        for i, point in enumerate(path_segment):\n            if i % 2 == 0:  # Left foot\n                footsteps.append({\n                    'position': point,\n                    'foot': 'left',\n                    'gait_params': gait_params\n                })\n            else:  # Right foot\n                footsteps.append({\n                    'position': point,\n                    'foot': 'right',\n                    'gait_params': gait_params\n                })\n\n        return footsteps\n"})}),"\n",(0,t.jsx)(e.h2,{id:"integration-with-isaac-perception-systems",children:"Integration with Isaac Perception Systems"}),"\n",(0,t.jsx)(e.p,{children:"Isaac Navigation integrates with Isaac's perception systems to enable robust navigation."}),"\n",(0,t.jsx)(e.h3,{id:"perception-planning-integration",children:"Perception-Planning Integration:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Obstacle Detection"}),": Real-time obstacle detection for path replanning"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Terrain Classification"}),": Understanding surface properties"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Human Detection"}),": Avoiding collisions with humans"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Object Tracking"}),": Handling moving obstacles"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"safety-considerations",children:"Safety Considerations:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Emergency Stop"}),": Immediate stopping when safety is compromised"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Safe Fallback"}),": Default behaviors when perception fails"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Collision Avoidance"}),": Maintaining safe distances from obstacles"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Human-Aware Navigation"}),": Special consideration for human safety"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Isaac Navigation provides specialized capabilities for humanoid robot navigation, accounting for the unique challenges of bipedal locomotion. By understanding path planning fundamentals, navigation pipelines, humanoid-specific challenges, and gait-aware planning concepts, you can implement effective navigation systems for humanoid robots. The integration with Isaac's perception systems enables robust navigation in real-world environments."}),"\n",(0,t.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Explain the difference between static and dynamic walking gaits for humanoid robots."}),"\n",(0,t.jsx)(e.li,{children:"Describe how center of mass management affects path planning for bipedal robots."}),"\n",(0,t.jsx)(e.li,{children:"Identify three key challenges in humanoid navigation that don't apply to wheeled robots."}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>o,x:()=>r});var a=i(6540);const t={},s=a.createContext(t);function o(n){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),a.createElement(s.Provider,{value:e},n.children)}}}]);